/* AUTOGENERATED FILE - DO NOT EDIT CONTENTS */

/* Table schema:
CREATE TABLE kv_store_8837ac96 (
  key TEXT NOT NULL PRIMARY KEY,
  value JSONB NOT NULL
);
*/

// View at https://supabase.com/dashboard/project/lmvuisccheszbanpaccg/database/tables

// This file provides a simple key-value interface for storing Figma Make data. It should be adequate for most small-scale use cases.
import { createClient } from "jsr:@supabase/supabase-js@2.49.8";
import { logger } from "./logger.tsx";

const client = () => createClient(
  Deno.env.get("SUPABASE_URL"),
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY"),
);

// Set stores a key-value pair in the database.
export const set = async (key: string, value: any): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_8837ac96").upsert({
    key,
    value
  });
  if (error) {
    throw new Error(error.message);
  }
};

// Get retrieves a key-value pair from the database.
export const get = async (key: string): Promise<any> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_8837ac96").select("value").eq("key", key).maybeSingle();
  if (error) {
    throw new Error(error.message);
  }
  return data?.value;
};

// Delete deletes a key-value pair from the database.
export const del = async (key: string): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_8837ac96").delete().eq("key", key);
  if (error) {
    throw new Error(error.message);
  }
};

// Sets multiple key-value pairs in the database.
export const mset = async (keys: string[], values: any[]): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_8837ac96").upsert(keys.map((k, i) => ({ key: k, value: values[i] })));
  if (error) {
    throw new Error(error.message);
  }
};

// Gets multiple key-value pairs from the database.
export const mget = async (keys: string[]): Promise<any[]> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_8837ac96").select("value").in("key", keys);
  if (error) {
    throw new Error(error.message);
  }
  return data?.map((d) => d.value) ?? [];
};

// Deletes multiple key-value pairs from the database.
export const mdel = async (keys: string[]): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_8837ac96").delete().in("key", keys);
  if (error) {
    throw new Error(error.message);
  }
};

// Search for key-value pairs by prefix.
export const getByPrefix = async (prefix: string): Promise<any[]> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_8837ac96").select("key, value").like("key", prefix + "%");
  if (error) {
    throw new Error(error.message);
  }
  return data?.map((d) => d.value) ?? [];
};

// ===== ENHANCED SUPABASE TABLE FUNCTIONS - NO FALLBACKS =====

// Create necessary tables for TaskFlow data
export const createTables = async (): Promise<void> => {
  const supabase = client();
  
  try {
    logger.info('Database Setup Check', 'Checking if TaskFlow tables exist...');

    // Try to check if tables exist by querying them
    const tableChecks = await Promise.allSettled([
      supabase.from('taskflow_projects_8837ac96').select('id').limit(1),
      supabase.from('taskflow_tasks_8837ac96').select('id').limit(1),
      supabase.from('taskflow_team_8837ac96').select('id').limit(1),
      supabase.from('taskflow_events_8837ac96').select('id').limit(1),
      supabase.from('taskflow_comments_8837ac96').select('id').limit(1),
      supabase.from('taskflow_attachments_8837ac96').select('id').limit(1),
      supabase.from('taskflow_time_logs_8837ac96').select('id').limit(1)
    ]);

    const tablesExist = tableChecks.every(result => result.status === 'fulfilled');

    if (tablesExist) {
      logger.success('Database Setup', 'All TaskFlow tables exist and are ready');
      return;
    }

    logger.error('Database Setup', {
      message: 'Tables do not exist. Table creation via Edge Functions is not supported.',
      required_action: 'Manual table creation required',
      location: 'Supabase SQL Editor',
      sql_file: 'DATABASE_SETUP.md',
      missing_tables: tableChecks.map((result, index) => {
        const tables = ['projects', 'tasks', 'team', 'events', 'comments', 'attachments', 'time_logs'];
        return result.status === 'rejected' ? tables[index] : null;
      }).filter(Boolean)
    });
    
    logger.warn('Database Setup', 'System will not function properly without database tables');
  } catch (error) {
    logger.error('Database Setup Error', { error: error.message, stack: error.stack });
    throw new Error('Critical: Database setup failed');
  }
};

// Project management functions - PURE DATABASE ONLY
export const insertProject = async (project: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Project Insert', `Starting insert for project: ${project.name}`);
  
  try {
    const { data, error } = await supabase
      .from('taskflow_projects_8837ac96')
      .insert({
        ...project,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      logger.error('Project Insert Failed', {
        project_name: project.name,
        project_id: project.id,
        error_message: error.message,
        error_details: error.details,
        error_hint: error.hint,
        error_code: error.code
      });

      // Provide more helpful error messages
      if (error.message?.includes('column') && error.message?.includes('does not exist')) {
        throw new Error(
          `Database schema error: ${error.message}. ` +
          `The database table needs to be updated. Please check DATABASE_SETUP.md for instructions on updating your database schema.`
        );
      }
      
      if (error.message?.includes('could not find') && error.message?.includes('column')) {
        throw new Error(
          `Database schema mismatch: ${error.message}. ` +
          `Your database table is missing required columns. Please run the SQL from DATABASE_SETUP.md to update your database schema.`
        );
      }
      
      throw new Error(`Failed to insert project "${project.name}" into database: ${error.message}`);
    }

    logger.success('Project Insert Success', {
      project_name: project.name,
      project_id: project.id,
      database_record: data
    });
  } catch (dbError) {
    logger.error('Project Insert Database Error', {
      project_name: project.name,
      project_id: project.id,
      error: dbError.message,
      stack: dbError.stack
    });
    
    // Re-throw with more context
    if (dbError.message?.includes('Database schema')) {
      throw dbError; // Already has helpful message
    }
    
    throw new Error(`Database connection failed for project "${project.name}": ${dbError.message}`);
  }
};

export const getProjects = async (): Promise<any[]> => {
  const supabase = client();
  
  logger.info('Projects Fetch', 'Fetching all projects from database');
  
  try {
    const { data, error } = await supabase
      .from('taskflow_projects_8837ac96')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      logger.error('Projects Fetch Failed', { error: error.message, details: error.details });
      throw new Error(`Failed to fetch projects: ${error.message}`);
    }

    logger.success('Projects Fetch Success', { count: data?.length || 0 });
    return data || [];
  } catch (error) {
    logger.error('Projects Fetch Database Error', { error: error.message });
    throw new Error(`Database error fetching projects: ${error.message}`);
  }
};

// Task management functions - PURE DATABASE ONLY
export const insertTask = async (task: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Task Insert', `Starting insert for task: ${task.title}`);
  
  try {
    const { data, error } = await supabase
      .from('tasks') // Changed from 'taskflow_tasks_8837ac96' to 'tasks'
      .insert({
        ...task,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      logger.error('Task Insert Failed', {
        task_title: task.title,
        task_id: task.id,
        project_id: task.project_id,
        error_message: error.message,
        error_details: error.details
      });
      
      throw new Error(`Failed to insert task "${task.title}" into database: ${error.message}`);
    }

    logger.success('Task Insert Success', {
      task_title: task.title,
      task_id: task.id,
      project_id: task.project_id
    });
  } catch (error) {
    logger.error('Task Insert Database Error', {
      task_title: task.title,
      error: error.message
    });
    
    throw new Error(`Database error inserting task "${task.title}": ${error.message}`);
  }
};

export const getTasks = async (filters?: { project_id?: string; assignee_id?: string }): Promise<any[]> => {
  const supabase = client();
  
  logger.info('Tasks Fetch', { filters });
  
  try {
    let query = supabase
      .from('tasks') // Changed from 'taskflow_tasks_8837ac96' to 'tasks'
      .select(`
        *,
        projects!inner(name)
      `)
      .order('created_at', { ascending: false });

    if (filters?.project_id) {
      query = query.eq('project_id', filters.project_id);
    }

    if (filters?.assignee_id) {
      query = query.eq('assignee', filters.assignee_id);
    }

    const { data, error } = await query;

    if (error) {
      logger.error('Tasks Fetch Failed', { filters, error: error.message });
      throw new Error(`Failed to fetch tasks: ${error.message}`);
    }

    // Transform data to match expected format
    const transformedData = (data || []).map(task => ({
      ...task,
      project_name: task.projects?.name || 'Unknown Project'
    }));

    logger.success('Tasks Fetch Success', { count: transformedData.length, filters });
    return transformedData;
  } catch (error) {
    logger.error('Tasks Fetch Database Error', { filters, error: error.message });
    throw new Error(`Database error fetching tasks: ${error.message}`);
  }
};

export const updateTask = async (taskId: string, updates: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Task Update', { task_id: taskId, updates });
  
  try {
    const { data, error } = await supabase
      .from('tasks') // Changed from 'taskflow_tasks_8837ac96' to 'tasks'
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', taskId)
      .select()
      .single();

    if (error) {
      logger.error('Task Update Failed', {
        task_id: taskId,
        updates,
        error: error.message
      });
      
      throw new Error(`Failed to update task ${taskId}: ${error.message}`);
    }

    logger.success('Task Update Success', { task_id: taskId, updated_record: data });
  } catch (error) {
    logger.error('Task Update Database Error', {
      task_id: taskId,
      error: error.message
    });
    
    throw new Error(`Database error updating task ${taskId}: ${error.message}`);
  }
};

export const deleteTask = async (taskId: string): Promise<void> => {
  const supabase = client();
  
  logger.info('Task Delete', { task_id: taskId });
  
  try {
    const { error } = await supabase
      .from('tasks')
      .delete()
      .eq('id', taskId);

    if (error) {
      logger.error('Task Delete Failed', {
        task_id: taskId,
        error: error.message
      });
      
      throw new Error(`Failed to delete task ${taskId}: ${error.message}`);
    }

    logger.success('Task Delete Success', { task_id: taskId });
  } catch (error) {
    logger.error('Task Delete Database Error', {
      task_id: taskId,
      error: error.message
    });
    
    throw new Error(`Database error deleting task ${taskId}: ${error.message}`);
  }
};

// Team management functions - PURE DATABASE ONLY
export const insertTeamMember = async (member: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Team Member Insert', `Starting insert for member: ${member.name}`);
  
  try {
    const { data, error } = await supabase
      .from('taskflow_team_8837ac96')
      .insert({
        ...member,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      logger.error('Team Member Insert Failed', {
        member_name: member.name,
        member_id: member.id,
        error: error.message
      });
      
      throw new Error(`Failed to insert team member "${member.name}": ${error.message}`);
    }

    logger.success('Team Member Insert Success', {
      member_name: member.name,
      member_id: member.id
    });
  } catch (error) {
    logger.error('Team Member Insert Database Error', {
      member_name: member.name,
      error: error.message
    });
    
    throw new Error(`Database error inserting team member "${member.name}": ${error.message}`);
  }
};

export const getTeamMembers = async (): Promise<any[]> => {
  const supabase = client();
  
  logger.info('Team Members Fetch', 'Fetching all team members from database');
  
  try {
    const { data, error } = await supabase
      .from('taskflow_team_8837ac96')
      .select('*')
      .order('name');

    if (error) {
      logger.error('Team Members Fetch Failed', { error: error.message });
      throw new Error(`Failed to fetch team members: ${error.message}`);
    }

    logger.success('Team Members Fetch Success', { count: data?.length || 0 });
    return data || [];
  } catch (error) {
    logger.error('Team Members Fetch Database Error', { error: error.message });
    throw new Error(`Database error fetching team members: ${error.message}`);
  }
};

// Utility function to get dashboard stats - PURE DATABASE ONLY
export const getDashboardStats = async (): Promise<any> => {
  const supabase = client();
  
  logger.info('Dashboard Stats', 'Calculating dashboard statistics from database');
  
  try {
    const [
      { data: tasks, error: tasksError },
      { data: projects, error: projectsError }
    ] = await Promise.all([
      supabase.from('taskflow_tasks_8837ac96').select('status, due_date, updated_at'),
      supabase.from('taskflow_projects_8837ac96').select('status')
    ]);

    if (tasksError || projectsError) {
      const error = tasksError || projectsError;
      logger.error('Dashboard Stats Failed', { error: error.message });
      throw new Error(`Failed to fetch dashboard stats: ${error.message}`);
    }

    const now = new Date();
    const today = now.toDateString();
    
    const stats = {
      openTasks: (tasks || []).filter(t => t.status !== 'Done').length,
      overdueTasks: (tasks || []).filter(t => 
        t.due_date && new Date(t.due_date) < now && t.status !== 'Done'
      ).length,
      completedToday: (tasks || []).filter(t => {
        return t.status === 'Done' && 
               t.updated_at && 
               new Date(t.updated_at).toDateString() === today;
      }).length,
      activeProjects: (projects || []).filter(p => p.status === 'Active').length
    };

    logger.success('Dashboard Stats Success', stats);
    return stats;
  } catch (error) {
    logger.error('Dashboard Stats Database Error', { error: error.message });
    throw new Error(`Database error calculating dashboard stats: ${error.message}`);
  }
};

// Event management functions - PURE DATABASE ONLY
export const insertEvent = async (event: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Event Insert', `Starting insert for event: ${event.title}`);
  
  try {
    const { data, error } = await supabase
      .from('taskflow_events_8837ac96')
      .insert({
        ...event,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      logger.error('Event Insert Failed', {
        event_title: event.title,
        event_id: event.id,
        error_message: error.message,
        error_details: error.details
      });
      
      throw new Error(`Failed to insert event "${event.title}" into database: ${error.message}`);
    }

    logger.success('Event Insert Success', {
      event_title: event.title,
      event_id: event.id,
      organizer_id: event.organizer_id
    });
  } catch (error) {
    logger.error('Event Insert Database Error', {
      event_title: event.title,
      error: error.message
    });
    
    throw new Error(`Database error inserting event "${event.title}": ${error.message}`);
  }
};

export const getEvents = async (filters?: { organizer_id?: string; start_date?: string; end_date?: string }): Promise<any[]> => {
  const supabase = client();
  
  logger.info('Events Fetch', { filters });
  
  try {
    let query = supabase
      .from('taskflow_events_8837ac96')
      .select('*')
      .order('start_datetime', { ascending: true });

    if (filters?.organizer_id) {
      query = query.eq('organizer_id', filters.organizer_id);
    }

    if (filters?.start_date) {
      query = query.gte('start_date', filters.start_date);
    }

    if (filters?.end_date) {
      query = query.lte('start_date', filters.end_date);
    }

    const { data, error } = await query;

    if (error) {
      logger.error('Events Fetch Failed', { filters, error: error.message });
      throw new Error(`Failed to fetch events: ${error.message}`);
    }

    logger.success('Events Fetch Success', { count: data?.length || 0, filters });
    return data || [];
  } catch (error) {
    logger.error('Events Fetch Database Error', { filters, error: error.message });
    throw new Error(`Database error fetching events: ${error.message}`);
  }
};

export const updateEvent = async (eventId: string, updates: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Event Update', { event_id: eventId, updates });
  
  try {
    const { data, error } = await supabase
      .from('taskflow_events_8837ac96')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', eventId)
      .select()
      .single();

    if (error) {
      logger.error('Event Update Failed', {
        event_id: eventId,
        updates,
        error: error.message
      });
      
      throw new Error(`Failed to update event ${eventId}: ${error.message}`);
    }

    logger.success('Event Update Success', { event_id: eventId, updated_record: data });
  } catch (error) {
    logger.error('Event Update Database Error', {
      event_id: eventId,
      error: error.message
    });
    
    throw new Error(`Database error updating event ${eventId}: ${error.message}`);
  }
};

// Comments management functions - PURE DATABASE ONLY
export const insertComment = async (comment: any): Promise<void> => {
  const supabase = client();
  
  logger.info('Comment Insert', `Starting insert for comment on ${comment.entity_type}:${comment.entity_id}`);
  
  try {
    const { data, error } = await supabase
      .from('taskflow_comments_8837ac96')
      .insert({
        ...comment,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      logger.error('Comment Insert Failed', {
        entity_type: comment.entity_type,
        entity_id: comment.entity_id,
        author_id: comment.author_id,
        error: error.message
      });
      
      throw new Error(`Failed to insert comment: ${error.message}`);
    }

    logger.success('Comment Insert Success', {
      comment_id: data.id,
      entity_type: comment.entity_type,
      entity_id: comment.entity_id
    });
  } catch (error) {
    logger.error('Comment Insert Database Error', {
      entity_type: comment.entity_type,
      entity_id: comment.entity_id,
      error: error.message
    });
    
    throw new Error(`Database error inserting comment: ${error.message}`);
  }
};

export const getComments = async (entityType: string, entityId: string): Promise<any[]> => {
  const supabase = client();
  
  logger.info('Comments Fetch', { entity_type: entityType, entity_id: entityId });
  
  try {
    const { data, error } = await supabase
      .from('taskflow_comments_8837ac96')
      .select('*')
      .eq('entity_type', entityType)
      .eq('entity_id', entityId)
      .order('created_at', { ascending: true });

    if (error) {
      logger.error('Comments Fetch Failed', { entity_type: entityType, entity_id: entityId, error: error.message });
      throw new Error(`Failed to fetch comments: ${error.message}`);
    }

    logger.success('Comments Fetch Success', { count: data?.length || 0, entity_type: entityType, entity_id: entityId });
    return data || [];
  } catch (error) {
    logger.error('Comments Fetch Database Error', { entity_type: entityType, entity_id: entityId, error: error.message });
    throw new Error(`Database error fetching comments: ${error.message}`);
  }
};